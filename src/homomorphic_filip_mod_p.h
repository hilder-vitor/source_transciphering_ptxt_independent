/**
 *  Implements a homomorphic version of the FiLIP stream cipher 
 * with f = XOR-THR, which described in the paper
 * 'Transciphering, using FiLIP and TFHE for an efficient delegation of computation' 
 * (https://eprint.iacr.org/2020/1373.pdf),
 * using FHE techniques from the paper  
 * 'SortingHat: Efficient Private Decision Tree Evaluation via Homomorphic 
 * Encryption and Transciphering'
 * (https://eprint.iacr.org/2022/757)
 * but considering messages modulo p, so it uses ceil(log(p)) iterations of the basic
 * binary homomorphic FiLIP
 */

#ifndef __HOM_FiLIP_MOD_P_XOR_THR__
#define __HOM_FiLIP_MOD_P_XOR_THR__

#include "filip.h"

#include "FINAL.h"

class HomomorphicFiLIPModP
{
    public:

        SchemeLWE& fhe;

        std::vector<NGSFFTctxt> enc_sk; // sent by the client
        int len_sk; // number of bits of secret key


        // values generated in the global setup
        std::vector<NGSFFTctxt> enc_not_sk;    // enc(NOT(sk[i]))
        std::vector<NGSFFTctxt> enc_X_to_2_sk; // enc(X^(2*sk[i]))
        std::vector<NGSFFTctxt> enc_X_to_not_2_sk; // enc(X^(2*NOT(sk[i])))


        // values generated by the p-dependent setup
        int p; // plaintext space of output FHE scheme
        int logp;
        std::vector<std::vector<ModQPoly>> sca_enc_b_t; // [i][j] --> enc(2^i * sk[j] * t(X) mod p) 
        std::vector<std::vector<ModQPoly>> sca_enc_not_b_t; // [i][j] --> enc(2^i*NOT(sk[j])*t(X) mod p) 

        std::vector<ModQPoly> scaled_test_polynomials; // [i] --> 2^i * t(X), where t(X) is the "test vector"


        // values selected by the whitenning and permutation 
        std::vector<NGSFFTctxt*> vec_ctxt_xor; // vector of vector ciphertexts encrypting the bits to be xored
        std::vector<ModQPoly*> ctxt_xor; // vector of scalar ciphertexts encrypting 2^k * t(X) * b for every bit b be xored
        std::vector<NGSFFTctxt*> ctxt_hw; // vector of vector encryptions of X^(2*b) for every bit b to be added for the hamming weight

        int size_subset; // number of bits of sk used to encrypt each bit

        int size_domain_thr; // number of bits added in the threshold function
        int threshold_limit; // added bits are compared to this limit

        int num_bits_xored; // number of bits that are xored with the threshold.
                            // We have: size_subset = size_domain_thr + num_bits_xored

        int B_ngs; // decomposition base used in the vector ciphertexts of NGS. 
        int l_ngs; // dimension of vector ciphertexts of NGS. l_ngs = log_{B_ngs}(Q)
        int log_B_ngs; // log(B_ngs) in base 2


        std::vector<int> whitening; // random bits used to mask permuted subset

        CSPRNG csprng; // cryptographically secure pseudorandom number generator


        /**
         * Set all the parameters and run the global setup
         *
         * log_B_ngs is the log_2 of the base B used in the decomposition of the
         * external products... The dimension of the vector ciphertexts used by the underlying
         * FHE scheme, namely, NGS, are defined by log_B_ngs and by q_boot
         */
        HomomorphicFiLIPModP(const FiLIP& filip, SchemeLWE& s_lwe, int log_B_ngs = 2);

        void run_global_setup(const vector<int>& sk);


        void run_p_dependent_setup(int p);


        /**
         *  Select a random subset of the encrypted bits of the secret key
         * and apply a whitening mask to it.
         *  Then, update the variables vec_ctxt_xor, ctxt_xor, and ctxt_hw
         * to store pointers this permuted and masked subset.
         *  pow_2 indicates which power of two (generated in the p-dependent setup) 
         * has to be used.
         */
        void subset_permut_whiten(int pow_2);


        /**
         *  Receives the initialization vector iv that was previously used by 
         * FiLIP to encrypt a binary vector m into the ciphertext c under a
         * secret key sk.
         *  Uses iv and the encryption of sk to homomorphically evaluate the 
         * decryption function of FiLIP on each c[i], generating one LWE ciphertext
         * encrypting
         * 2^0*m[0]+2^1*m[1]+...+2^(l-1)*m[l-1] 
         * and whose plaintext space is p 
         * (i.e., the message is multiplied by Delta = round(q_boot / p).
         * It assumes that c.size() == l == ceil(log(p)/log(2))
         */
        Ctxt_LWE transform(long int iv, const std::vector<int>& c);


        /**
         *  Let mi be the bit encrypted by ci (by FiLIP).
         *  Apply the FiLIP encryption homomorphically to the bit ci given as input,
         *  returning a scalar NTRU ciphertext encrypting 2^k * mi. 
         *  This functi on is used by the HomomorphicFiLIP::transform.
         */
        ModQPoly enc_bit(int ci, int k);

        /**
         *  Auxiliar function used to encrypt and decrypt. 
         *  It uses the permutation of a subset of the secret key generated
         * by the function HomomorphicFiLIP::subset_permut_whiten(),
         * denoted by x_1, x_2, ..., x_(n-k), y_1, ..., y_k, and outputs
         * a scalar NTRU encryption of 2^k * b where
         *      b = x_1 XOR ... XOR x_(n-k) XOR THR(y_1, ..., y_k)
         * and THR(y_1, ..., y_k) is 0 if sum y_i < threshold_limit and 1 otherwise.
         */
        ModQPoly compute_xor_thr(int k);



        /**
         *  Receives a vector of LWE ciphertexts and decrypt them.
         */
        std::vector<int> dec(std::vector<Ctxt_LWE> c);

        /**
         *  Receives a vector of LWE ciphertexts and the messages they are supposed
         * to encrypt. Computes the log of noise of each of ciphertext 
         * and returns the maximum of these logs.
         */
        double noise(const std::vector<Ctxt_LWE>& c, const std::vector<int>& m);


};

std::ostream& operator<<(std::ostream& os, const HomomorphicFiLIPModP& u);

#endif
